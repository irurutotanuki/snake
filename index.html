<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>マージスネークオンライン</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press-Start-2P', 'MS Gothic', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #0c0a09;
        }
        canvas {
            background-color: #1c1917;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.07) 2px, transparent 2px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.07) 2px, transparent 2px);
            background-size: 50px 50px;
            image-rendering: auto;
        }
        #joystick-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            background: rgba(50, 50, 50, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #joystick-thumb {
            width: 60px;
            height: 60px;
            background: rgba(200, 200, 200, 0.5);
            border-radius: 50%;
            position: absolute;
            transition: transform 0.1s;
        }
        #boost-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 100px;
            height: 100px;
            background: rgba(251, 146, 60, 0.4);
            border: 4px solid rgba(251, 146, 60, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px black;
        }
        #boost-button:active {
            transform: scale(0.9);
            background: rgba(249, 115, 22, 0.6);
        }
        .server-btn.active {
            background-color: #facc15;
            color: #111827;
            box-shadow: 0 0 10px #facc15;
        }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-center h-screen overflow-hidden">

    <div class="fixed top-4 left-4 text-left z-10 p-2 bg-black bg-opacity-30 rounded max-w-xs">
        <h1 class="text-2xl text-yellow-300">マージスネーク</h1>
        <div>サーバー: <span id="serverName">1</span> | プレイヤー: <span id="playerCount">0</span></div>
        <div>スコア: <span id="score">0</span></div>
    </div>
    
    <!-- ミニマップ -->
    <canvas id="minimapCanvas" class="fixed top-28 left-4 border-2 border-gray-500 bg-black bg-opacity-50 rounded" width="150" height="150"></canvas>

    <div class="fixed top-4 right-4 z-10 p-2 bg-black bg-opacity-30 rounded">
        <h2 class="text-lg text-center">リーダーボード</h2>
        <ol id="leaderboard" class="list-decimal list-inside"></ol>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- 操作UI -->
    <div id="joystick-container">
        <div id="joystick-thumb"></div>
    </div>
    <button id="boost-button">ブースト</button>
    
    <!-- 開始/ゲームオーバー モーダル -->
    <div id="modal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center transition-opacity duration-300 z-50">
        <div class="bg-gray-800 border-4 border-yellow-500 p-8 rounded-lg text-center shadow-2xl w-11/12 max-w-md">
            <h2 id="modal-title" class="text-4xl md:text-5xl mb-2 text-yellow-500">マージスネーク</h2>
            <p class="text-lg md:text-xl mb-4" id="modal-subtitle">コインを集めて一番大きなスネークを目指せ！</p>
            <div id="final-score-container" class="hidden">
                 <p class="text-xl md:text-2xl mb-2">最終スコア:</p>
                 <p id="finalScore" class="text-4xl mb-6 text-green-400">0</p>
            </div>
            <input type="text" id="playerNameInput" placeholder="名前を入力" class="w-full p-2 rounded bg-gray-700 text-white text-center text-xl mb-4" maxlength="12">
            
            <!-- サーバー選択UI -->
            <div id="server-selection" class="my-4">
                <h3 class="text-xl mb-2">サーバー選択</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button class="server-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md transition-all active" data-server="1">S1 <span id="server-1-count">(0/30)</span></button>
                    <button class="server-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md transition-all" data-server="2">S2 <span id="server-2-count">(0/30)</span></button>
                    <button class="server-btn bg-gray-700 hover:bg-gray-600 p-2 rounded-md transition-all" data-server="3">S3 <span id="server-3-count">(0/30)</span></button>
                    <button class="server-btn bg-green-800 hover:bg-green-700 p-2 rounded-md transition-all" data-server="B1">BOT <span id="server-B1-count">(10/30)</span></button>
                </div>
            </div>

            <button id="playButton" class="w-full bg-blue-600 hover:bg-blue-800 text-white font-bold py-3 px-6 rounded text-xl md:text-2xl transition-transform transform hover:scale-105 mt-4">
                プレイ
            </button>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection, writeBatch, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // === 初期設定 ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const elements = {
            score: document.getElementById('score'),
            serverName: document.getElementById('serverName'),
            playerCount: document.getElementById('playerCount'),
            leaderboard: document.getElementById('leaderboard'),
            modal: document.getElementById('modal'),
            modalTitle: document.getElementById('modal-title'),
            modalSubtitle: document.getElementById('modal-subtitle'),
            finalScoreContainer: document.getElementById('final-score-container'),
            finalScore: document.getElementById('finalScore'),
            playerNameInput: document.getElementById('playerNameInput'),
            playButton: document.getElementById('playButton'),
            serverButtons: document.querySelectorAll('.server-btn'),
            joystick: document.getElementById('joystick-container'),
            joystickThumb: document.getElementById('joystick-thumb'),
            boostButton: document.getElementById('boost-button')
        };
        
        // === ゲーム定数 ===
        const WORLD_SIZE = 3000;
        const BASE_SPEED = 2.5;
        const BOOST_SPEED = 5;
        const TURN_SPEED = 0.07;
        const SNAKE_RADIUS = 10;
        const MAX_PLAYERS_PER_SERVER = 30;
        const MAX_FOOD_COUNT = 150;
        const FOOD_LIFETIME = 15000;
        const PLAYER_TIMEOUT = 6000; // 最適化：タイムアウト時間を少し延長
        const BOT_COUNT = 10; // 最適化：BOTの数を10に削減
        const INITIAL_SCORE = 30;

        // === ゲーム状態 ===
        let localPlayer = null;
        let allPlayers = {};
        let bots = [];
        let food = {};
        let camera = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2, zoom: 1 };
        let joystick = { active: false, angle: 0, dx: 0, dy: 0 };
        let isBoosting = false;
        let animationFrameId;

        // === Firebase関連 ===
        let db, auth, userId, appId;
        let currentServerId = null;
        let selectedServerId = '1';
        let unsubPlayers, unsubFood;
        let serverCountUnsubscribers = [];
        let foodManagementInterval;

        // === Firebase 初期化 ===
        async function initializeFirebase() {
            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyDFt4WECRt8td1fvbUA-IFm94O66lt5iSY",
                    authDomain: "sportnetworkfor-ruby.firebaseapp.com",
                    projectId: "sportnetworkfor-ruby",
                    storageBucket: "sportnetworkfor-ruby.firebasestorage.app",
                    messagingSenderId: "829403903709",
                    appId: "1:829403903709:web:83ff5431f084fe3ba04d34",
                    measurementId: "G-VQPE8FKLNK"
                };
                appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                onAuthStateChanged(auth, user => {
                    if (user) {
                        userId = user.uid;
                        listenToAllServerCounts();
                    } else {
                        signInAnonymously(auth);
                    }
                });
            } catch (e) { console.error("Firebase init failed:", e); }
        }
        
        function getCollectionPath(serverId, collectionName) {
            const path = `merge_snake_v5_server_${serverId}_${collectionName}`;
            return `/artifacts/${appId}/public/data/${path}`;
        }

        function listenToAllServerCounts() {
            serverCountUnsubscribers.forEach(unsub => unsub());
            serverCountUnsubscribers = [];
            
            const serverIds = ['1', '2', '3', 'B1'];
            serverIds.forEach(serverId => {
                const playersCollection = collection(db, getCollectionPath(serverId, 'players'));
                const unsub = onSnapshot(playersCollection, snapshot => {
                    let count = 0;
                    const now = Date.now();
                    snapshot.forEach(doc => {
                        const playerData = doc.data();
                        if (playerData.lastSeen && (now - playerData.lastSeen < PLAYER_TIMEOUT * 2)) {
                            count++;
                        }
                    });

                    if (serverId === 'B1') {
                        count += BOT_COUNT;
                    }
                    const countEl = document.getElementById(`server-${serverId}-count`);
                    if (countEl) {
                        countEl.textContent = `(${count}/${MAX_PLAYERS_PER_SERVER})`;
                    }
                });
                serverCountUnsubscribers.push(unsub);
            });
        }
        
        async function connectAndStart(serverId) {
            if (currentServerId) {
                 if(unsubPlayers) unsubPlayers();
                 if(unsubFood) unsubFood();
                 if (foodManagementInterval) clearInterval(foodManagementInterval);
                 await deleteDoc(doc(db, getCollectionPath(currentServerId, 'players'), userId)).catch(()=>{});
            }

            currentServerId = serverId;
            elements.serverName.textContent = serverId;

            allPlayers = {}; // プレイヤーリストをリセット
            bots = [];
            if(serverId === 'B1') {
                initializeBots(BOT_COUNT);
            }

            listenForGameUpdates();
            
            const foodCollection = collection(db, getCollectionPath(currentServerId, 'food'));
            const foodSnapshot = await getDocs(foodCollection);
            if(foodSnapshot.empty){
                spawnInitialFood();
            }

            foodManagementInterval = setInterval(manageFood, 5000);

            startGame();
        }

        // === ゲームロジック ===
        function startGame() {
            const playerName = elements.playerNameInput.value || `Player${Math.floor(Math.random() * 1000)}`;
            elements.modal.classList.add('hidden');
            
            const startPos = { x: 100 + Math.random() * (WORLD_SIZE - 200), y: 100 + Math.random() * (WORLD_SIZE - 200) };
            localPlayer = {
                id: userId,
                name: playerName,
                segments: [startPos],
                angle: Math.random() * 2 * Math.PI,
                targetAngle: 0,
                score: INITIAL_SCORE,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                lastSeen: Date.now()
            };
            
            isBoosting = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function gameLoop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        let lastUpdateTime = 0;
        function update() {
            if (!localPlayer) return;

            // --- Player Update ---
            if (joystick.active) {
                localPlayer.targetAngle = joystick.angle;
            }
            let angleDiff = localPlayer.targetAngle - localPlayer.angle;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            localPlayer.angle += angleDiff * TURN_SPEED;

            const speed = isBoosting && localPlayer.score > 10 ? BOOST_SPEED : BASE_SPEED;
            const head = localPlayer.segments[0];
            const newHead = {
                x: head.x + Math.cos(localPlayer.angle) * speed,
                y: head.y + Math.sin(localPlayer.angle) * speed,
            };

            if (newHead.x < 0 || newHead.x > WORLD_SIZE || newHead.y < 0 || newHead.y > WORLD_SIZE) {
                handleDeath(true);
                return;
            }
            
            localPlayer.segments.unshift(newHead);

            const maxSegments = Math.floor(localPlayer.score);
            while (localPlayer.segments.length > maxSegments) {
                localPlayer.segments.pop();
            }

            if (isBoosting && localPlayer.score > 10) {
                localPlayer.score -= 0.1;
                if (Math.random() < 0.1) {
                    const lastSegment = localPlayer.segments[localPlayer.segments.length - 1];
                    spawnFood(1, lastSegment.x, lastSegment.y);
                }
            }
            
            // --- Bots Update ---
            if(currentServerId === 'B1') updateBots();

            checkFoodCollision();
            checkPlayerCollision();

            camera.x += (localPlayer.segments[0].x - camera.x) * 0.1;
            camera.y += (localPlayer.segments[0].y - camera.y) * 0.1;

            if (Date.now() - lastUpdateTime > 250) { // 最適化：通信頻度をさらに落とす
                updatePlayerInFirestore();
                lastUpdateTime = Date.now();
            }
            
            elements.score.textContent = Math.floor(localPlayer.score);
            updateLeaderboard();
        }

        function checkFoodCollision() {
            const head = localPlayer.segments[0];
            const batch = writeBatch(db);
            let eaten = false;
            for (const id in food) {
                const f = food[id];
                const dist = Math.hypot(head.x - f.x, head.y - f.y);
                if (dist < SNAKE_RADIUS + f.value) { 
                    localPlayer.score += f.value;
                    const foodDocRef = doc(db, getCollectionPath(currentServerId, 'food'), id);
                    batch.delete(foodDocRef);
                    delete food[id];
                    eaten = true;
                }
            }
            if (eaten) batch.commit().catch(console.error);
        }

        function checkPlayerCollision() {
            const head = localPlayer.segments[0];
            const opponents = [...Object.values(allPlayers), ...bots];

            for (const otherPlayer of opponents) {
                if (otherPlayer.id === userId) continue;
                for (let i = 0; i < otherPlayer.segments.length; i++) {
                    const segment = otherPlayer.segments[i];
                    const dist = Math.hypot(head.x - segment.x, head.y - segment.y);
                    if (dist < SNAKE_RADIUS * 1.5) {
                        handleDeath(false);
                        return;
                    }
                }
            }
        }

        function handleDeath(isOutOfBounds = false) {
            if (!isOutOfBounds && localPlayer && localPlayer.segments.length > 0) {
                spawnFood(localPlayer.score, localPlayer.segments[0].x, localPlayer.segments[0].y, true);
            }
            
            const scoreBeforeDeath = localPlayer ? Math.floor(localPlayer.score) : 0;
            if (currentServerId) {
                 deleteDoc(doc(db, getCollectionPath(currentServerId, 'players'), userId));
            }
            
            localPlayer = null;
            cancelAnimationFrame(animationFrameId);
            if (foodManagementInterval) clearInterval(foodManagementInterval);


            elements.modal.classList.remove('hidden');
            elements.modalTitle.textContent = isOutOfBounds ? "範囲外" : "ゲームオーバー";
            elements.modalSubtitle.textContent = isOutOfBounds ? "ワールドの外に出てしまいました。" : "";
            elements.finalScoreContainer.classList.remove('hidden');
            elements.finalScore.textContent = scoreBeforeDeath;
            elements.playButton.textContent = "もう一度プレイ";
        }

        function draw() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            const viewBounds = {
                left: camera.x - (canvas.width / 2 / camera.zoom) - 50,
                right: camera.x + (canvas.width / 2 / camera.zoom) + 50,
                top: camera.y - (canvas.height / 2 / camera.zoom) - 50,
                bottom: camera.y + (canvas.height / 2 / camera.zoom) + 50
            };

            ctx.fillStyle = '#1c1917';
            ctx.fillRect(0, 0, WORLD_SIZE, WORLD_SIZE);
            
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 20;
            ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);

            for (const id in food) {
                const f = food[id];
                if (f.x > viewBounds.left && f.x < viewBounds.right && f.y > viewBounds.top && f.y < viewBounds.bottom) {
                    ctx.beginPath();
                    const radius = 3 + Math.log(f.value || 1) * 2;
                    ctx.arc(f.x, f.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = f.color;
                    ctx.fill();
                }
            }
            
            const playersToDraw = [...Object.values(allPlayers), ...bots];
            playersToDraw.sort((a,b) => (a.score || 0) - (b.score || 0)).forEach(p => {
                if (p.segments && p.segments.length > 0) {
                    const head = p.segments[0];
                    const buffer = SNAKE_RADIUS * Math.sqrt(p.score || INITIAL_SCORE) * 2;
                    if (head.x > viewBounds.left - buffer && head.x < viewBounds.right + buffer &&
                        head.y > viewBounds.top - buffer && head.y < viewBounds.bottom + buffer) {
                        drawSnake(p);
                    }
                }
            });
            if(localPlayer) drawSnake(localPlayer);

            ctx.restore();
            
            drawMinimap();
        }
        
        function drawMinimap() {
            minimapCtx.clearRect(0, 0, 150, 150);
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            minimapCtx.fillRect(0, 0, 150, 150);
            minimapCtx.strokeStyle = 'gray';
            minimapCtx.strokeRect(0, 0, 150, 150);
            
            const scale = 150 / WORLD_SIZE;
            const playersToMap = [...Object.values(allPlayers), ...bots];
            
            playersToMap.forEach(p => {
                 if(p.segments && p.segments.length > 0) {
                    minimapCtx.fillStyle = p.color;
                    minimapCtx.fillRect(p.segments[0].x * scale, p.segments[0].y * scale, 3, 3);
                }
            });
            
            if(localPlayer && localPlayer.segments.length > 0) {
                minimapCtx.fillStyle = 'yellow';
                minimapCtx.beginPath();
                minimapCtx.arc(localPlayer.segments[0].x * scale, localPlayer.segments[0].y * scale, 4, 0, 2 * Math.PI);
                minimapCtx.fill();
            }
        }

        function drawSnake(player) {
            for (let i = 0; i < player.segments.length; i++) {
                const part = player.segments[i];
                const radius = SNAKE_RADIUS * (1 - i / (player.segments.length * 2));
                ctx.beginPath();
                ctx.arc(part.x, part.y, Math.max(2, radius), 0, 2 * Math.PI);
                ctx.fillStyle = player.color;
                ctx.fill();
            }
            const head = player.segments[0];
            const eyeOffset = SNAKE_RADIUS * 0.4;
            const eyeRadius = SNAKE_RADIUS * 0.2;
            const angle = player.angle;
            
            const eye1X = head.x + Math.cos(angle + Math.PI / 2) * eyeOffset;
            const eye1Y = head.y + Math.sin(angle + Math.PI / 2) * eyeOffset;
            const eye2X = head.x + Math.cos(angle - Math.PI / 2) * eyeOffset;
            const eye2Y = head.y + Math.sin(angle - Math.PI / 2) * eyeOffset;

            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(eye1X, eye1Y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eye2X, eye2Y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(eye1X + Math.cos(angle)*2, eye1Y + Math.sin(angle)*2, eyeRadius*0.5, 0, 2 * Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eye2X + Math.cos(angle)*2, eye2Y + Math.sin(angle)*2, eyeRadius*0.5, 0, 2 * Math.PI); ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = '16px "Press-Start-2P"';
            ctx.textAlign = 'center';
            ctx.fillText(player.name, head.x, head.y - SNAKE_RADIUS - 10);
        }

        function updateLeaderboard() {
            const playersWithLocal = {...allPlayers};
            if(localPlayer) playersWithLocal[userId] = localPlayer;
            const allEntities = [...Object.values(playersWithLocal), ...bots];

            const sortedPlayers = allEntities.sort((a, b) => (b.score || 0) - (a.score || 0)).slice(0, 5);
            elements.leaderboard.innerHTML = '';
            sortedPlayers.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: ${Math.floor(p.score)}`;
                if(p.id === userId) li.style.color = '#facc15';
                elements.leaderboard.appendChild(li);
            });
        }
        
        // === BOTロジック ===
        function initializeBots(count) {
             for (let i = 0; i < count; i++) {
                const bot = {
                    id: `bot_${i}`,
                    name: `BOT ${i + 1}`,
                    segments: [{ x: Math.random() * WORLD_SIZE, y: Math.random() * WORLD_SIZE }],
                    angle: Math.random() * 2 * Math.PI,
                    targetAngle: Math.random() * 2 * Math.PI,
                    score: INITIAL_SCORE,
                    color: `hsl(${Math.random() * 360}, 40%, 30%)`,
                    isBot: true,
                    stateTimer: 0,
                };
                bots.push(bot);
            }
        }

        function updateBots(){
            bots.forEach(bot => {
                bot.stateTimer--;
                if(bot.stateTimer <= 0) {
                    bot.targetAngle = bot.angle + (Math.random() - 0.5) * Math.PI;
                    bot.stateTimer = Math.random() * 150 + 50;
                }

                let angleDiff = bot.targetAngle - bot.angle;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                bot.angle += angleDiff * TURN_SPEED * 0.6;

                const speed = BASE_SPEED * 0.9;
                const head = bot.segments[0];
                const newHead = {
                    x: head.x + Math.cos(bot.angle) * speed,
                    y: head.y + Math.sin(bot.angle) * speed,
                };
                
                let isDead = false;
                if (newHead.x < 0 || newHead.x > WORLD_SIZE || newHead.y < 0 || newHead.y > WORLD_SIZE) {
                    isDead = true;
                }

                if (!isDead) {
                    const opponents = [...Object.values(allPlayers), ...bots, localPlayer].filter(p => p);
                    for (const otherPlayer of opponents) {
                        if (bot.id === otherPlayer.id) continue;
                        for (let i = 0; i < otherPlayer.segments.length; i++) {
                            const segment = otherPlayer.segments[i];
                            const dist = Math.hypot(newHead.x - segment.x, newHead.y - segment.y);
                            if (dist < SNAKE_RADIUS * 1.5) {
                                isDead = true;
                                break; 
                            }
                        }
                        if (isDead) break;
                    }
                }

                if (isDead) {
                    spawnFood(bot.score, bot.segments[0].x, bot.segments[0].y, true);
                    bot.segments = [{ x: Math.random() * WORLD_SIZE, y: Math.random() * WORLD_SIZE }];
                    bot.score = INITIAL_SCORE;
                    return; 
                }
                
                bot.segments.unshift(newHead);
                const maxSegments = Math.floor(bot.score);
                while (bot.segments.length > maxSegments) {
                    bot.segments.pop();
                }

                for (const id in food) {
                    const f = food[id];
                    const dist = Math.hypot(head.x - f.x, head.y - f.y);
                    if (dist < SNAKE_RADIUS + f.value) {
                        bot.score += f.value;
                    }
                }
            });
        }


        // === Firebaseとの通信 ===
        function listenForGameUpdates() {
            unsubPlayers = onSnapshot(collection(db, getCollectionPath(currentServerId, 'players')), snapshot => {
                const currentIds = {};
                const now = Date.now();
                snapshot.forEach(d => {
                    const playerData = d.data();
                    if (d.id !== userId && now - (playerData.lastSeen || 0) > PLAYER_TIMEOUT) {
                        deleteDoc(d.ref);
                        return;
                    }
                    if (d.id !== userId) allPlayers[d.id] = playerData;
                    currentIds[d.id] = true;
                });
                Object.keys(allPlayers).forEach(id => {
                    if (!currentIds[id]) delete allPlayers[id];
                });
                let playerCount = Object.keys(allPlayers).length + (localPlayer ? 1 : 0);
                if (currentServerId === 'B1') {
                    playerCount += bots.length;
                }
                elements.playerCount.textContent = playerCount;
            });
            unsubFood = onSnapshot(collection(db, getCollectionPath(currentServerId, 'food')), snapshot => {
                snapshot.docChanges().forEach(change => {
                    if(change.type === 'added') food[change.doc.id] = change.doc.data();
                    if(change.type === 'removed') delete food[change.doc.id];
                });
            });
        }

        async function updatePlayerInFirestore() {
            if (!userId || !localPlayer) return;
            const playerDoc = doc(db, getCollectionPath(currentServerId, 'players'), userId);
            localPlayer.lastSeen = Date.now();
            const data = { ...localPlayer };
            data.segments = data.segments.filter((_, i) => i % 6 === 0); // 最適化：データ量をさらに削減
            await setDoc(playerDoc, data);
        }
        
        async function spawnInitialFood() {
             const batch = writeBatch(db);
             for(let i = 0; i < MAX_FOOD_COUNT; i++) {
                const foodId = doc(collection(db, 'idGenerator')).id;
                const foodDocRef = doc(db, getCollectionPath(currentServerId, 'food'), foodId);
                batch.set(foodDocRef, {
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    value: 1,
                    color: `hsl(${Math.random() * 360}, 100%, 75%)`,
                    createdAt: Date.now()
                });
             }
             await batch.commit().catch(console.error);
        }

        async function spawnFood(score, x, y, isDeath = false) {
            const batch = writeBatch(db);
            const now = Date.now();
            if (isDeath && score > 0) {
                let remainingScore = score;
                const coinValues = { large: 25, medium: 10, small: 1 };
                
                const numLarge = Math.floor(remainingScore / coinValues.large);
                for (let i = 0; i < numLarge; i++) {
                     batch.set(doc(collection(db, getCollectionPath(currentServerId, 'food'))), {
                        x: x + (Math.random() - 0.5) * 200, y: y + (Math.random() - 0.5) * 200,
                        value: coinValues.large, color: '#facc15', createdAt: now });
                }
                remainingScore %= coinValues.large;

                const numMedium = Math.floor(remainingScore / coinValues.medium);
                 for (let i = 0; i < numMedium; i++) {
                     batch.set(doc(collection(db, getCollectionPath(currentServerId, 'food'))), {
                        x: x + (Math.random() - 0.5) * 200, y: y + (Math.random() - 0.5) * 200,
                        value: coinValues.medium, color: '#c0c0c0', createdAt: now });
                }
                remainingScore %= coinValues.medium;

                 for (let i = 0; i < remainingScore; i++) {
                     batch.set(doc(collection(db, getCollectionPath(currentServerId, 'food'))), {
                        x: x + (Math.random() - 0.5) * 200, y: y + (Math.random() - 0.5) * 200,
                        value: coinValues.small, color: '#cd7f32', createdAt: now });
                }
            } else if (!isDeath && score > 0) {
                batch.set(doc(collection(db, getCollectionPath(currentServerId, 'food'))), {
                    x: x, y: y, value: 1, color: `hsl(${Math.random() * 360}, 100%, 75%)`, createdAt: now });
            }
             await batch.commit().catch(e => console.error("Failed to spawn food:", e));
        }

        async function manageFood() {
            if (!currentServerId) return;
            const batch = writeBatch(db);
            const now = Date.now();
            let deletedCount = 0;
            for (const id in food) {
                if (now - food[id].createdAt > FOOD_LIFETIME) {
                    batch.delete(doc(db, getCollectionPath(currentServerId, 'food'), id));
                    deletedCount++;
                }
            }

            const currentFoodCount = Object.keys(food).length - deletedCount;
            if (currentFoodCount < MAX_FOOD_COUNT) {
                 for(let i=0; i < (MAX_FOOD_COUNT - currentFoodCount); i++) {
                    batch.set(doc(collection(db, getCollectionPath(currentServerId, 'food'))), {
                         x: Math.random() * WORLD_SIZE, y: Math.random() * WORLD_SIZE,
                         value: 1, color: `hsl(${Math.random() * 360}, 100%, 75%)`, createdAt: now });
                }
            }

            await batch.commit().catch(console.error);
        }

        // === イベントリスナー ===
        elements.playButton.addEventListener('click', () => connectAndStart(selectedServerId));
        
        elements.serverButtons.forEach(b => {
            b.addEventListener('click', () => {
                selectedServerId = b.dataset.server;
                elements.serverButtons.forEach(btn => btn.classList.remove('active'));
                b.classList.add('active');
            });
        });

        window.addEventListener('beforeunload', () => {
            if(userId && currentServerId) deleteDoc(doc(db, getCollectionPath(currentServerId, 'players'), userId));
        });
        
        // Joystick & Boost controls
        function handlePointerDown(e) {
            const rect = elements.joystick.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - rect.left - rect.width / 2;
            const y = touch.clientY - rect.top - rect.height / 2;
            if (Math.hypot(x,y) < rect.width / 2) {
                joystick.active = true;
                handlePointerMove(e);
            }
        }
        function handlePointerMove(e) {
            if (!joystick.active) return;
            e.preventDefault();
            const rect = elements.joystick.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            let dx = touch.clientX - (rect.left + rect.width / 2);
            let dy = touch.clientY - (rect.top + rect.height / 2);
            const dist = Math.hypot(dx, dy);
            joystick.angle = Math.atan2(dy, dx);
            if (dist > rect.width/2 - 30) {
                dx = Math.cos(joystick.angle) * (rect.width/2 - 30);
                dy = Math.sin(joystick.angle) * (rect.width/2 - 30);
            }
            elements.joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
        }
        function handlePointerUp() {
            joystick.active = false;
            elements.joystickThumb.style.transform = 'translate(0,0)';
        }

        elements.joystick.addEventListener('mousedown', handlePointerDown);
        elements.joystick.addEventListener('touchstart', handlePointerDown);
        window.addEventListener('mousemove', handlePointerMove);
        window.addEventListener('touchmove', handlePointerMove, { passive: false });
        window.addEventListener('mouseup', handlePointerUp);
        window.addEventListener('touchend', handlePointerUp);

        elements.boostButton.addEventListener('mousedown', () => isBoosting = true);
        elements.boostButton.addEventListener('mouseup', () => isBoosting = false);
        elements.boostButton.addEventListener('touchstart', (e) => { e.preventDefault(); isBoosting = true; });
        elements.boostButton.addEventListener('touchend', () => isBoosting = false);
        
        // === 初期化実行 ===
        initializeFirebase();
    </script>
</body>
</html>

